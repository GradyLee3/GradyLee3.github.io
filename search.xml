<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyISAM与InnoDB 的区别（9个不同点）</title>
      <link href="/2021/10/23/MyISAM%E4%B8%8EInnoDB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%889%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%89/"/>
      <url>/2021/10/23/MyISAM%E4%B8%8EInnoDB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%889%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li><p><strong>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</strong> </p></li><li><p><strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</strong> </p></li><li><p><strong>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</strong></p><p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。<br>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p></li><li><p><strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</strong></p><blockquote><p>那么为什么InnoDB没有了这个变量呢？</p><p>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。</p><p>如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</p></blockquote></li><li><p><strong>Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</strong></p></li><li><p><strong>MyISAM表格可以被压缩后进行查询操作</strong></p></li><li><p><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong><br>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p><blockquote><p>例如：</p><p>t_user(uid, uname, age, sex) innodb;</p><p>uid PK<br>无其他索引<br>update t_user set age=10 where uid=1;             命中索引，行锁。</p><p>update t_user set age=10 where uid != 1;           未命中索引，表锁。</p><p>update t_user set age=10 where name=’chackca’;    无索引，表锁。</p></blockquote></li><li><p><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</strong></p></li><li><p><strong>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI</strong></p><p>​    <strong>Innodb：frm是表定义文件，ibd是数据文件</strong></p><p>​    <strong>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</strong></p></li></ol><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><ol><li><strong>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</strong></li><li><strong>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</strong></li><li><strong>系统奔溃后，MyISAM恢复起来更困难，能否接受；</strong></li><li><strong>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</strong></li></ol><h1 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</strong></p><h1 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解和反射</title>
      <link href="/2021/10/21/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/10/21/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><ul><li>Annotation是从JDK5.0开始弓|入的新技术.</li><li>Annotation的作用:<br>不是程序本身可以对程序作出解释.(这一点和注释(comment)没什么区别)<br><strong>可以被其他程序(比如:编译器等)读取.</strong></li><li>Annotation的格式:<br>注解是以”@注释名”在代码中存在的,还可以添加一-些参数值,例如:@SuppressWarnings(value=”unchecked”).</li><li>Annotation在哪里使用?<br>可以附加在package , class , method , field 等上面,相当于给他们添加了额外的辅助信息，<br>我们可以通过反射机制编程实现对这些元数据的访问</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul><li><p><strong>@Override</strong>: 定义在java.lang.Override中,此注释只适用于修辞方法,表示-一个方法声明打算<br>重写超类中的另一个方法声明.</p></li><li><p><strong>@Deprecated</strong> : 定义在java.lang.Deprecated中,此注释可以用于修辞方法,属性,类,表示不<br>鼓励程序员使用这样的元素,通常是因为它很危险或者存在更好的选择.</p></li><li><p><strong>@SuppressWarnings</strong> : 定义在java.lang. SuppressWarnings中,用来抑制编译时的警告信息.与前两个注释有所不同,你需要添加一-个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了.</p><ul><li><p>@SuppressWarnings(“all”)</p></li><li><p>@SuppressWarnings(“unchecked”)</p></li><li><p>@SuppressWarnings(value={“unchecked” ,”deprecation”})</p></li></ul></li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ul><li><p>元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明.</p></li><li><p>这些类型和它们所支持的类在java.lang.annotation包中可以找到.( <strong>@Target , @Retention，</strong><br><strong>@Documented，@Inherited</strong> )</p><ul><li><p><strong>@Target</strong>:  用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</p></li><li><p><strong>@Retention</strong> : 表示需要在什么级别保存该注释信息，用于描述注解的生命周期</p><p>(SOURCE &lt;CL _ASS &lt; <strong>RUNTIME</strong>)</p></li><li><p>@Document: 说明该注解将被包含在javadoc中</p></li><li><p>@Inherited: 说明子类可以<strong>继承</strong>父类中的该注解</p></li></ul></li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li>使用<strong>@interface</strong>自定义注解时,自动继承了java.lang.annotation.Annotation接口</li><li><strong>分析</strong>:<ul><li>@ interface用来声明一个注解,格式: public @ interface注解名{定义内容}</li><li>其中的每一个方法实际上是声明了一个配置参数.</li><li>方法的名称就是参数的名称.</li><li>返回值类型就是参数的类型(返回值只能是基本类型,Class , String，enum ).</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时,经常使用空字符串，0作为默认值.</li></ul></li></ul><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="静态-VS-动态语言"><a href="#静态-VS-动态语言" class="headerlink" title="静态 VS 动态语言"></a>静态 VS 动态语言</h2><ul><li><strong>动态语言</strong><ul><li>是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li><li>主要动态语言: Object-C、 C#、 JavaScript、 PHP、 Python等。</li></ul></li><li><strong>静态语言</strong><ul><li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、 C、C++。</li><li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性上编程的时候更加灵活!</li></ul></li></ul><h2 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h2><ul><li><p>Reflection (反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class C = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为: 反射</p><blockquote><p>正常方式: 引入需要的”包类”名称 → 通过new实例化 → 取得实例化对象<br>反射方式: 实例化对象 → getClass()方法 → 得到完整的“包类”名称</p></blockquote></li></ul><h2 id="Java反射机制研究及应用"><a href="#Java反射机制研究及应用" class="headerlink" title="Java反射机制研究及应用"></a>Java反射机制研究及应用</h2><ul><li>Java反射机制提供的功能<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul></li></ul><h2 id="Java反射优点和缺点"><a href="#Java反射优点和缺点" class="headerlink" title="Java反射优点和缺点"></a>Java反射优点和缺点</h2><ul><li><p>优点:</p><p>可以实现动态创建对象和编译，体现出很大的灵活性</p></li><li><p>缺点:<br>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM,我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p></li></ul><h2 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h2><ul><li>java.lang.Class : 代表一个类</li><li>java.lang.reflect.Method : 代表类的方法</li><li>java.lang.reflect.Field : 代表类的成员变量</li><li>java.lang.reflect.Constructor : 代表类的构造器</li></ul><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>在Object类中定义了以下的方法，此方法将被所有子类继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。</p><p><img src="https://gitee.com/gradylee3/picgo-img/raw/master/注解与反射1.png" alt="注解与反射1"></p></li><li><p>对象照镜子后可以得到的信息: 某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。</p><ul><li>Class 本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在JVM中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类 是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul></li></ul><h2 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h2><ul><li><p>static ClassforName(String name)</p><blockquote><p>返回指定类名name的Class对象</p></blockquote></li></ul><ul><li><p>Object newInstance()</p><blockquote><p>调用缺省构造函数，返回Class对象的一 个实例</p></blockquote></li></ul><ul><li><p>getName()</p><blockquote><p>返回此Class对象所表示的实体(类，接口，数组类或void)的名称。</p></blockquote></li></ul><ul><li><p>Class getSuperClass()</p><blockquote><p>返回当前Class对象的父类的Class对象</p></blockquote></li></ul><ul><li><p>Class[] getinterfaces()</p><blockquote><p>获取当前Class对象的接口</p></blockquote></li></ul><ul><li><p>ClassL oader getClassLoader()</p><blockquote><p>返回该类的类加载器</p></blockquote></li></ul><ul><li><p>Constructor[ getConstructors()</p><blockquote><p>返回一个包含某些Constructor对象的数组</p></blockquote></li></ul><ul><li><p>Method getMothed(String name,Class.. T)</p><blockquote><p>返回一个Method对象，此对象的形参类型为param Type </p></blockquote></li></ul><ul><li><p>Field[] getDeclaredFields()</p><blockquote><p>返回Field对象的一个数组</p></blockquote></li></ul><h2 id="获取Class类的实例"><a href="#获取Class类的实例" class="headerlink" title="获取Class类的实例"></a>获取Class类的实例</h2><ol><li><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br></pre></td></tr></table></figure></li><li><p>已知某个类的实例，调用该实例的getClass()方法获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = person.getClass();</span><br></pre></td></tr></table></figure></li><li><p>已知一-个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;demo01. Student&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>内置基本数据类型可以直接用类名.Type</p></li><li><p>还可以利用ClassLoader</p></li></ol><h2 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象?"></a>哪些类型可以有Class对象?</h2><ul><li>class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</li><li>interface: 接口</li><li>[]: 数组</li><li>enum :枚举</li><li>annotation: 注解@interface</li><li>primitive type: 基本数据类型</li><li>void</li></ul><h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><ul><li>堆<ul><li>存放new的对象和数组</li><li>可以被所有的线程共享，不会存放别的对象引用</li></ul></li><li>栈<ul><li>存放基本变量类型(会包含这个基本类型的具体数值)</li><li>引用对象的变量(会存放这个引用在堆里面的具体地址)</li></ul></li><li>方法区<ul><li>可以被所有的线程共享</li><li>包含了所有的class和static变量</li></ul></li></ul><h2 id="了解：类的加载过程"><a href="#了解：类的加载过程" class="headerlink" title="了解：类的加载过程"></a>了解：类的加载过程</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p><ol><li>类的加载(Load): 将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</li><li>类的链接(Link)：将类的二进制数据合并到JRE中</li><li>类的初始化(Initialize)：JVM负责对类进行初始化</li></ol><h2 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h2><ul><li>加载: 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成-个代表这个类的java.lang.Class对象.</li><li>链接: 将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul><li>验证: 确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备:正式为类变量(static) 分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li><li>解析:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。</li></ul></li><li>初始化:<ul><li>执行类构造器<clinit> ()方法的过程。类构造器&lt; clinit&gt; ()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器)。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证-个类的<clinit> ()方法在多线程环境中被正确加锁和同步。</li></ul></li></ul><h2 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化"></a>什么时候会发生类的初始化</h2><ul><li>类的主动引用(一定会发生类的初始化)<ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一 个类的对象</li><li>调用类的静态成员(除了final常量)和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li></ul></li><li>类的被动引用(不会发生类的初始化)<ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如: 当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</li></ul></li></ul><h2 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h2><ul><li>类加载的作用: 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时<br>数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象， 作为方法区中类数据的访问<br>入口。</li><li>类缓存: 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维<br>持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li><li>类加载器作用是用来把类(class)装载进内存的。JVM规范定义了如下类型的类的加载器。<ul><li>引导类加载器:用C++编写的，是JVM自带的类加载器， 负责Java平台核心库，用来装载核心类库。该加载器无法直接获取</li><li>扩展类加载器:负责jre/ib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库</li><li>系统类加载器:负责java -classpath或-Djava.class. path所指的目录下的类与jar包装入工作，是最常用的加载器</li></ul></li></ul><h1 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h1><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><ul><li><p>通过反射获取运行时类的完整结构<br>Field、Method、 Constructor、 Superclass、 Interface、 Annotation</p><ul><li><p>实现的全部接口</p></li><li><p>所继承的父类</p></li><li><p>全部的构造器</p></li><li><p>全部的方法</p></li><li><p>全部的Field</p></li><li><p>注解</p></li></ul></li><li><p>小结</p><ul><li>在实际的操作中,取得类的信息的操作代码，并不会经常开发。</li><li>定要熟悉java.lang.reflect包的作用，反射机制。</li><li>如何取得属性、方法、构造器的名称，修饰符等。</li></ul></li></ul><h2 id="有了Class对象，能做什么"><a href="#有了Class对象，能做什么" class="headerlink" title="有了Class对象，能做什么?"></a>有了Class对象，能做什么?</h2><ul><li>创建类的对象: 调用Class对象的newInstance()方法<ol><li>类必须有一个无参数的构造器。</li><li>类的构造器的访问权限需要足够</li></ol></li></ul><ul><li><strong>思考?</strong> 难道没有无参的构造器就不能创建对象了吗?只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</li><li>步骤如下:<ol><li>通过Class类的getDeclaredConstructor(Class … parameter Types)取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象</li></ol></li></ul><h2 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h2><ul><li><p>通过反射，调用类中的方法，通过Method类完成。</p><ol><li>通过Class类的getMethod(String name,Clas..parameterTypes)方法取得一个Method对象r并设置此方法操作时所需要的参数类型。</li><li>之后使用Object invgke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li></ol></li><li><p>Object invoke(Object obj, Object … args)</p><ul><li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li><li>若原方法若为静态方法,此时形参Object obj可为null</li><li>若原方法形参列表为空，则Object[] args为null </li><li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的</li><li>setAccessible(true)方法，将可访问private的方法。</li></ul></li></ul><h2 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h2><ul><li>Method和Field、 Constructor对象都有setAccessible()方法。</li><li>setAccessible作用是启动和禁用访问安全检查的开关。</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li><li>使得原本无法访问的私有成员也可以访问</li></ul></li><li>参数值为false则指示反射的对象应该实施Java语言访问检查</li></ul><h2 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h2><ul><li><p>Java采用泛型擦除的机制来引入泛型, Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题,但是,一旦编译完成,所有和泛型有关的类型全部擦除</p></li><li><p>为了通过反射操作这些类型, Java新增了ParameterizedType , GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型.</p><blockquote><p>ParameterizedType : 表示一 种参数化类型,比如Collection<String><br>GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型<br>TypeVariable : 是各种类型变量的公共父接口<br>WildcardType : 代表一种通配符类型表达式</p></blockquote></li></ul><h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><ul><li>getAnnotations</li><li>getAnnotation</li></ul><h2 id="练习：ORM"><a href="#练习：ORM" class="headerlink" title="练习：ORM"></a>练习：ORM</h2><ul><li><p>了解什么是ORM?</p><ul><li>Object relationship Mapping —&gt;对象关系映射</li><li>类和表结构对应</li><li>属性和字段对应</li><li>对象和记录对应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>001</td><td>小明</td><td>3</td></tr><tr><td>002</td><td>小红</td><td>30</td></tr></tbody></table></div><ul><li>要求: 利用注解和反射完成类和表结构的映射关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除Gitee仓库的文件</title>
      <link href="/2021/10/21/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Gitee%E4%BB%93%E5%BA%93%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2021/10/21/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Gitee%E4%BB%93%E5%BA%93%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何删除Gitee仓库的文件"><a href="#如何删除Gitee仓库的文件" class="headerlink" title="如何删除Gitee仓库的文件"></a>如何删除Gitee仓库的文件</h1><ol><li><p>clone仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone Gitee库链接</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>cd进入clone下来的仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd 本地库名</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm 要删除的文件名及其后缀</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>提交删除文件后的仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;对本次提交描述信息&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 帮助 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runnable和Thread比较</title>
      <link href="/2021/10/20/runnable%E5%92%8Cthread%E6%AF%94%E8%BE%83/"/>
      <url>/2021/10/20/runnable%E5%92%8Cthread%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在线程使用过程中，我们肯定会用到Runnable与Thread，前者的实现方式是实现其接口即可，后者的实现方式是继承其类。两者实现方式带来最明显的区别就是，由于Java不允许多继承，因此实现了Runnable接口可以再继承其他类，但是Thread明显不可以。</p></blockquote><h1 id="Runnable和Thread比较"><a href="#Runnable和Thread比较" class="headerlink" title="Runnable和Thread比较"></a>Runnable和Thread比较</h1><p>如上所述，Runnable相比Thread存在明显的优点，同时也是两者最大的区别。这点就不再做阐述，这里对于网络很多文章中存在的明显的错误文字总结进行一下论证：<br><strong>Runnable可以实现多个相同的程序代码的线程去共享同一个资源，而Thread不可以？</strong><br>我们以实际的代码样例来论证这个观点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread 实现资源共享</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itbird</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票----&gt;&quot;</span> + (<span class="keyword">this</span>.total--));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runnable 实现资源共享</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itbird</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunable t1 = <span class="keyword">new</span> MyRunable();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票----&gt;&quot;</span> + (<span class="keyword">this</span>.total--));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过实际样例代码编写以及运行结果对比，我们知道<strong>很多人说的Thread类不能共享资源，其实并不是不能，只是不适合</strong><br>其实我们从Thread源码中也可以看到，当以Thread方式去实现资源共享时，实际上源码内部是将thread向下转型为了Runnable，实际上内部依然是以Runnable形式去实现的资源共享</p><h1 id="Runnable为什么不可以直接run"><a href="#Runnable为什么不可以直接run" class="headerlink" title="Runnable为什么不可以直接run"></a>Runnable为什么不可以直接run</h1><p>如果问出这个问题，代表您对Java的线程基础知识以及多线程理念还不太熟悉或者说并没有真正理解，这里做简单阐述。</p><ul><li><p>多线程原理：相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）。</p></li><li><p>调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。</p></li><li><p>start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程</p></li><li><p>run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的</p></li></ul><p>解释到这里，相信各位看官心里有种“了然大明白”的感觉，<strong>runnable其实相对于一个task，并不具有线程的概念，如果你直接去调用runnable的run，其实就是相当于直接在主线程中执行了一个函数而已，并未开启线程去执行</strong>，所以显而易见，如果你在代码中直接通过这种方式run了一个runnable，明显您的程序的主线程就直接悲催了，各种资源不足现象的崩溃日志会接踵而至，而且遇到这种问题的时候，如果没有一定的研发经验和坚持，很有可能采取错误的解决策略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">java.lang.OutOfMemoryError&lt;&lt;no stack trace available&gt;&gt;</span><br><span class="line">很多开发遇到这个问题时，问一下度娘，知道原因是资源没有合理利用，使用完了没有释放，从而导致内存溢出，立马就想到了两种解决方案</span><br><span class="line">1、把用完的程序的资源释放</span><br><span class="line">2、加大虚拟机的存储容量</span><br><span class="line">明显这时采取哪种解决策略都是错误的，因为真正的问题在于您的代码中错误使用方法，导致资源的不合理利用</span><br><span class="line">所以有时解决问题，还是要去找根本原因，不能为了解决问题而解决问题</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>Runnable和Thread相比优点有：</p><p>（1）由于Java不允许多继承，因此实现了Runnable接口可以再继承其他类，但是Thread明显不可以<br>（2）Runnable可以实现多个相同的程序代码的线程去共享同一个资源，而Thread并不是不可以，而是相比于Runnable来说，不太适合，具体原因文章中有。</p></li><li><p>Runnable为什么不可以直接run</p><p>阐述文章中已有，Runnable其实相对于一个Task，并不具有线程的概念，如果你直接去调用Runnable的run，其实就是相当于直接在主线程中执行了一个函数而已，并未开启线程去执行，带来的“灾害”文章中有。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2021/10/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/10/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><ul><li><p>多任务</p></li><li><p>多线程</p></li><li><p>程序.进程.线程</p></li><li><p>Process与Thread</p><ul><li>说起进程，就不得不说下程序。程序是指令和数据的有序集合,其本身没有任何运行的含义，是一个静态的概念。</li><li>而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。</li><li>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的的单位。</li></ul></li><li><p>核心概念</p><ul><li><p>线程就是独立的执行路径;</p></li><li><p>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程;</p></li><li><p>main()称之为主线程，为系统的入口，用于执行整个程序;</p></li><li><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度,调度器是与</p></li><li><p>操作系统紧密相关的，先后顺序是不能认为的干预的。</p></li><li><p>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制;</p></li><li><p>线程会带来额外的开销，如cpu调度时间，并发控制开销。</p></li><li><p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</p></li></ul></li></ul><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><ul><li><h2 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h2><ol><li>Thread class: 继承Thread类（重点）</li><li>Runnable接口: 实现Runnable接口（重点）</li><li>Callable接口: 实现Callable接口（了解）</li></ol></li><li><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul><li><p>自定义线程类继承Thread类</p></li><li><p>重写run()方法，编写线程执行体</p></li><li><p>创建线程对象，调用start()方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一: 继承Thread类，重写run()方法，调用start开启线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：注意，线程开启不一定立刻执行，由CPU调度执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start()方法开启线程</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在娱乐---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h2><ul><li><p>定义MyRunnable类实现Runnable接口</p></li><li><p>实现run()方法，编写线程执行体</p></li><li><p>创建线程对象，调用start()方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式2，实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnbale接口的实现类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启线程，代理</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在娱乐---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>继承Thread类<ul><li>子类继承Thread类具备多线程能力</li><li>启动线程:子类对象. start()</li><li>不建议使用:避免OOP单继承局限性</li></ul></li><li>实现Runnable接口<ul><li>实现接口Runnable具有多线程能力</li><li>启动线程:传入目标对象+ Thread对象.start()</li><li>推荐使用:避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</li></ul></li></ul></li><li><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟购买火车票</span></span><br><span class="line"><span class="comment">//多个线程同时操作同一个对象</span></span><br><span class="line"><span class="comment">//发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticketNums&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿了第&quot;</span>+ticketNums--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 ticket = <span class="keyword">new</span> TestThread4();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小张&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟龟兔赛跑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//胜利者</span></span><br><span class="line">    <span class="keyword">private</span> String winner;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟兔子休息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>)&amp;&amp;i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">boolean</span> flag=gameover(i);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;跑了&quot;</span>+i+<span class="string">&quot;步&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否完成比赛</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">gameover</span><span class="params">(<span class="keyword">int</span> steps)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span> (winner!=<span class="keyword">null</span>)&#123;<span class="comment">//已经存在胜利者了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(steps&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">            winner=Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;Winner is &quot;</span>+winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><ol><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务: ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行: Future<Boolean> result1 = ser.submit(t1);</li><li>获取结果: boolean r1 = result1 .get()</li><li>关闭服务: ser.shutdownNow();</li></ol></li></ul><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><ul><li><h2 id="线程状态-1"><a href="#线程状态-1" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>创建状态</li><li>就绪状态</li><li>阻塞状态</li><li>运行状态</li><li>思维状态</li></ul></li><li><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><ul><li>setPriority(int newPriority) ：更改线程的优先级</li><li>static void sleep(long millis)：在指定的毫秒数内让当前正在执行的线程休眠</li><li>void join()：等待该线程终止</li><li>static void yield()：暂停当前正在执行的线程对象，并执行其他线程</li><li>void interrupt()：中断线程，别用这个方式</li><li>boolean isAlive()：测试线程是否处于活动状态</li></ul></li><li><h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><ul><li><p>不推荐使用JDK提供的stop()、destroy()方法。[已废弃]</p></li><li><p>推荐线程自己停止下来</p></li><li><p>建议使用一个标志位进行终止变量，当flag=false,则终止线程运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试stop</span></span><br><span class="line"><span class="comment">//1.建议线程正常停止---&gt;利用次数，不建议死循环</span></span><br><span class="line"><span class="comment">//2.建议使用标志位---&gt;设置一个标志位</span></span><br><span class="line"><span class="comment">//3.不要使用stop或者destroy等果实或者JDK不建议使用的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.设置一个标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run......Thread&quot;</span>+i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置一个公开的方法停止线程，转换标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">//调用top方法切换标志位，让线程停止</span></span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程该停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><ul><li><p>sleep (时间)指定当前线程阻塞的毫秒数;</p></li><li><p>sleep存在异常InterruptedException;</p></li><li><p>sleep时间达到后线程进入就绪状态;</p></li><li><p>sleep可以模拟网络延时，倒计时等。</p></li><li><p>每一个对象都有一个锁， sleep不会释放锁;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tenDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(num--);</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><ul><li><p>礼让线程，让当前正在执行的线程暂停，但不阻塞</p></li><li><p>将线程从运行状态转为就绪状态</p></li><li><p>让cpu重新调度，礼让不一定成功，看CPU心情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYied</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYied myYied = <span class="keyword">new</span> MyYied();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYied,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYied,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYied</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">        Thread.yield();<span class="comment">//礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="线程强行执行"><a href="#线程强行执行" class="headerlink" title="线程强行执行"></a>线程强行执行</h2><ul><li><p>合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试join方法</span></span><br><span class="line"><span class="comment">// 想象为插队</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;VIP来了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们的线程</span></span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">200</span>)&#123;</span><br><span class="line">                thread.join();<span class="comment">//插队</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h2><ul><li><p>Thread.State</p><p>线程状态。线程可以处于以下状态之一:</p><ul><li><p>NEW</p><p>尚未启动的线程处于此状态。</p></li><li><p>RUNNABLE</p><p>在Java虛拟机中执行的线程处于此状态。</p></li><li><p>BLOCKED</p><p>被阻塞等待监视器锁定的线程处于此状态。</p></li><li><p>WAITING</p><p>正在等待另一个线程执行特定动作的线程处于此状态。</p></li><li><p>TIMED_ WAITING</p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p></li><li><p>TERMINATED</p><p>已退出的线程处于此状态。</p></li></ul><p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//观测测试线程的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;//////&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//观测状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//NEW</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观测启动后</span></span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line">        state=thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//Run</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state!= Thread.State.TERMINATED)&#123;<span class="comment">//只要线程不终止，就一直输出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            state=thread.getState();<span class="comment">//更新线程状态</span></span><br><span class="line">            System.out.println(state);<span class="comment">//输出状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p></li><li><p>线程的优先级用数字表示，范围从1~10.</p><ul><li>Thread.MIN PRIORITY = 1;</li><li>Thread.MAX PRIORITY = 10;</li><li>Thread.NORM_ PRIORITY = 5;</li></ul></li><li><p>使用以下方式改变或获取优先级</p><ul><li>getPriority() . setPriority(int XXX)</li></ul></li><li><p>注：</p><ol><li>优先级低只是意味着获得调度的概率低.并不是优先级低就不会被调用了.这都是看CPU的调度</li><li>优先级的设定建议在start()调度前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试线程的优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        Mypriority mypriority = <span class="keyword">new</span> Mypriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mypriority);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mypriority);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(mypriority);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(mypriority);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先设置优先级，再启动</span></span><br><span class="line">        t1.setPriority(<span class="number">2</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2.setPriority(<span class="number">4</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3.setPriority(<span class="number">5</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mypriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul><li><p>线程分为用户线程和守护线程</p></li><li><p>虚拟机必须确保用户线程执行完毕</p></li><li><p>虚拟机不用等待守护线程执行完毕</p></li><li><p>如：后台记录操作日志，监控内存，垃圾回收等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试守护线程</span></span><br><span class="line"><span class="comment">//上帝守护你</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);<span class="comment">//默认false表示是用户线程，正常的线程都是用户线程</span></span><br><span class="line"></span><br><span class="line">        thread.start();<span class="comment">//上帝守护线程启动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(you).start();<span class="comment">//你 用户线程启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝守护着你&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你一生都开心&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===HelloWorld===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><ul><li><h2 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li><p>并发：同一个对象被多个线程同时操作</p></li><li><p>处理多线程问题时,多个线程访问同一个对象,并且某些线程还想修改这个对象.这时候我们就需要线程同步.线程同步其实就是一种等待机制,多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用</p></li><li><p>形成条件：队列+锁</p></li><li><p>由于同一进程的多个线程共享同一块存储空间,在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized ;当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题:</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起;</li><li>在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时，引起性能问题;</li><li>如果一个优先级高的线程等待一 个优先级低的线程释放锁会导致优先级倒置,引起性能问题.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不安全的买票</span></span><br><span class="line"><span class="comment">//线程不安全，有负数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket buyTicket = <span class="keyword">new</span> BuyTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">&quot;小王&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNum=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//外部停止方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketNum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticketNum--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/10/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/10/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>计算机网络：计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p></li><li><p>网络编程目的：无线电，数据交互，通信，传播交流信息</p></li></ul><h1 id="网络通信要素"><a href="#网络通信要素" class="headerlink" title="网络通信要素"></a>网络通信要素</h1><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><ul><li><p>端口表示计算机上的一个程序的进程</p><ul><li>不同的进程有不同的端口号，原来区分软件</li><li>被规定0~65535</li><li>单个协议下，端口号不能冲突</li><li>端口分类：<ol><li>公有端口: 0~1023</li><li>HTTP: 80</li><li>HTTPS: 443</li><li>FTP: 21</li><li>TELENT: 23</li><li>程序注册端口：1024~49151，分配用户或者程序<ul><li>Tomcat: 8080</li><li>MySQL: 3306</li><li>Oracle: 1521</li></ul></li></ol></li></ul></li><li><p>动态、私有：49152~65535</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsata -ano <span class="comment">#查看所有的端口</span></span><br><span class="line">netsata -ano|findstr <span class="string">&quot;5900&quot;</span> <span class="comment">#查看指定的端口</span></span><br><span class="line">tastlist|findstr <span class="string">&quot;8696&quot;</span> <span class="comment">#查看指定端口的进程</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInetSocketAddress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InetSocketAddress socketAddress=<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress socketAddress2=<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        System.out.println(socketAddress);</span><br><span class="line">        System.out.println(socketAddress2);</span><br><span class="line"></span><br><span class="line">        System.out.println(socketAddress.getAddress());</span><br><span class="line">        System.out.println(socketAddress.getHostName());<span class="comment">//地址</span></span><br><span class="line">        System.out.println(socketAddress.getPort());<span class="comment">//端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li><p>客户端</p><ul><li><p>连接服务器Socket</p></li><li><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.要知道服务器的地址,端口号</span></span><br><span class="line">            InetAddress serverIP=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">9999</span>;</span><br><span class="line">            <span class="comment">//2.创建一个socke链接</span></span><br><span class="line">             socket=<span class="keyword">new</span> Socket(serverIP,port);</span><br><span class="line">            <span class="comment">//3.发送消息IO流</span></span><br><span class="line">             os= socket.getOutputStream();</span><br><span class="line">             os.write(<span class="string">&quot;helloworld&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(os!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>服务器</p><ul><li><p>建立服务的端口ServerSocket</p></li><li><p>等待用户的链接accept</p></li><li><p>接收用的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="keyword">null</span>;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">//1.要有一个地址</span></span><br><span class="line">         serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">          <span class="comment">//2.等待客户端链接过来</span></span><br><span class="line">          socket = serverSocket.accept();</span><br><span class="line">          <span class="comment">//3. 读取客户端的消息</span></span><br><span class="line">          is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//管道流</span></span><br><span class="line">          baos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">          <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="keyword">int</span> len;</span><br><span class="line">          <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">              baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//关闭资源</span></span><br><span class="line">          <span class="keyword">if</span>(baos!=<span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  is.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(socket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  socket.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(is!=<span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  serverSocket.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Socket连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">//创建一个输出流</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;d:/aaa.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//写出文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=fileInputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知服务器结束</span></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//传输完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定服务器接收完毕，才能断开连接</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        ByteOutputStream byteOutputStream = <span class="keyword">new</span> ByteOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span> ((len2=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            byteOutputStream.write(buffer2,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteOutputStream.toString());</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        byteOutputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">//监听客服端连接</span></span><br><span class="line">        Socket accept = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待客户端连接</span></span><br><span class="line">        <span class="comment">//获取输入流</span></span><br><span class="line">        InputStream inputStream = accept.getInputStream();</span><br><span class="line">        <span class="comment">//文件输出</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:/receive.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知客户端接收完毕</span></span><br><span class="line">        OutputStream outputStream = accept.getOutputStream();</span><br><span class="line">        fileOutputStream.write(<span class="string">&quot;接收完毕，可以断开&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul><li><h2 id="发短信"><a href="#发短信" class="headerlink" title="发短信"></a>发短信</h2><p>​    不用连接，需要知道对方地址</p><ul><li><p>发送端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要连接服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 建立一个Socket</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//2.建个包</span></span><br><span class="line">        String msg=<span class="string">&quot;你好服务器&quot;</span>;</span><br><span class="line">        InetAddress localhost = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port=<span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据，数据长度起始，发送给谁</span></span><br><span class="line">        DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(msg.getBytes(), <span class="number">0</span>, msg.getBytes().length, localhost, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送包</span></span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要等待客户端的连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//开放端口</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//接收数据包</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">        datagramSocket.receive(datagramPacket);<span class="comment">//阻塞接收</span></span><br><span class="line">        System.out.println(datagramPacket.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(datagramPacket.getData(),<span class="number">0</span>,datagramPacket.getLength()));</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h2 id="循环发送消息"><a href="#循环发送消息" class="headerlink" title="循环发送消息"></a>循环发送消息</h2><ul><li><p>发送端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpSendDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DatagramSocket Socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//准备数据：控制台读取System.in</span></span><br><span class="line">        BufferedReader Reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String data = Reader.readLine();</span><br><span class="line">            <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line">            DatagramPacket Packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>));</span><br><span class="line">            Socket.send(Packet);</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpReceiveDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备接收包裹</span></span><br><span class="line">            <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container, <span class="number">0</span>, container.length);</span><br><span class="line">            socket.receive(packet);<span class="comment">//阻塞式接收包裹</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//断开连接 bye</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">            String receiveData = <span class="keyword">new</span> String(data, <span class="number">0</span>, data.length);</span><br><span class="line">            System.out.println(receiveData);</span><br><span class="line">            <span class="keyword">if</span>(receiveData.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h2 id="在线咨询"><a href="#在线咨询" class="headerlink" title="在线咨询"></a>在线咨询</h2><p>两个人既可以是发送端，也可以是接收端</p><ul><li><p>发送端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader Reader=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fromIP;</span><br><span class="line">        <span class="keyword">private</span> String toIP;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkSend</span><span class="params">(<span class="keyword">int</span> fromIP, String toIP, <span class="keyword">int</span> toPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fromIP = fromIP;</span><br><span class="line">        <span class="keyword">this</span>.toIP = toIP;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        socket = <span class="keyword">new</span> DatagramSocket(fromIP);</span><br><span class="line">        Reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String data = Reader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line">                DatagramPacket Packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, <span class="keyword">new</span> InetSocketAddress(toIP, toPort));</span><br><span class="line">                socket.send(Packet);</span><br><span class="line">                <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkReceive</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String msgfrom;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkReceive</span><span class="params">(<span class="keyword">int</span> port,String msgfrom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.msgfrom=msgfrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备接收包裹</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container, <span class="number">0</span>, container.length);</span><br><span class="line">                socket.receive(packet);<span class="comment">//阻塞式接收包裹</span></span><br><span class="line">                <span class="comment">//断开连接 bye</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">                String receiveData = <span class="keyword">new</span> String(data, <span class="number">0</span>, data.length);</span><br><span class="line">                System.out.println(msgfrom+<span class="string">&quot;:&quot;</span>+receiveData);</span><br><span class="line">                <span class="keyword">if</span> (receiveData.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>学生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkStudent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开启两个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">7777</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>)).start();;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="number">8888</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>老师</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">5555</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="number">9999</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android思维导图</title>
      <link href="/2021/10/11/Android%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2021/10/11/Android%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Android平台概述"><a href="#第一章-Android平台概述" class="headerlink" title="第一章 Android平台概述"></a>第一章 Android平台概述</h1><p><img src="https://i.loli.net/2021/10/10/WPZ4JnbqzHufgm8.jpg" alt="Android平台概述.jpg"></p><h1 id="第二章-Android程序初探"><a href="#第二章-Android程序初探" class="headerlink" title="第二章 Android程序初探"></a>第二章 Android程序初探</h1><p><img src="https://i.loli.net/2021/10/10/TrXCMEse5JbGlhA.jpg" alt="Android程序初探.jpg"></p><h1 id="第三章-Android程序基本控件的使用"><a href="#第三章-Android程序基本控件的使用" class="headerlink" title="第三章 Android程序基本控件的使用"></a>第三章 Android程序基本控件的使用</h1><p><img src="https://i.loli.net/2021/10/20/ncNpeWmoD5Z3Gq4.jpg" alt="Android程序基本控件的使用.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-I/O框架</title>
      <link href="/2021/10/11/IO%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/10/11/IO%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><ul><li><h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><p> 概念：内存与存储设备之间传输数据的通道</p></li></ul><h1 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h1><ul><li><h2 id="按方向"><a href="#按方向" class="headerlink" title="按方向"></a>按方向</h2><ol><li>输入流：将&lt;存储设备&gt;中的内容读入到&lt;内存&gt;中</li><li>输出流：将&lt;内存&gt;中的内容写入到&lt;存储设备&gt;中</li></ol></li></ul><ul><li><h2 id="按单位"><a href="#按单位" class="headerlink" title="按单位"></a>按单位</h2><ol><li>字节流：以字节为单位，可以读写所有数据</li><li>字符流：以字符为单位，只能读写文本数据</li></ol></li></ul><ul><li><h2 id="按功能："><a href="#按功能：" class="headerlink" title="按功能："></a>按功能：</h2><ol><li>节点流：具有实际传输数据的读写功能</li><li>过滤流：在节点流的基础之上增强功能</li></ol></li></ul><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><ul><li><h2 id="字节流的父类（抽象类）："><a href="#字节流的父类（抽象类）：" class="headerlink" title="字节流的父类（抽象类）："></a>字节流的父类（抽象类）：</h2><ol><li><p>InputStream：字节输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>OutputStream：字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>&#123;&#125;  </span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><ol><li><p>FileInputStream：文件字节输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//从流中读取多个字节，将读到内容存入b数组，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</span></span></span><br></pre></td></tr></table></figure></li><li><p>FileOutputStream：文件字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//一次写多个字节，将b数组中所有字节，写入输出流。</span></span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><h2 id="文件缓冲流"><a href="#文件缓冲流" class="headerlink" title="文件缓冲流"></a>文件缓冲流</h2><ol><li><p>缓冲流：BufferedInputStream/BufferedOutputStream</p><ul><li><p>提高IO效率，减少访问磁盘的次数</p></li><li><p>数据存储在缓冲区中，flush是将缓冲区的内容写入文件中，也可以直接close</p></li></ul></li></ol></li></ul><ul><li><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><ol><li><p>对象流：ObjectOutputStream/BufferedIntputStream</p><ul><li><p>增强了缓冲区功能</p></li><li><p>增强了读写8种基本数据类型和字符串功能</p></li><li><p>增强了读写对象的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject() <span class="comment">//从流中读取一个对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj) <span class="comment">//向流中写入一个对象</span></span><br></pre></td></tr></table></figure><p><strong>使用流传输对象的过程称为序列化、反序列化</strong></p></li></ul></li><li><p>序列化和反序列化：</p><ul><li><p>定义：</p><p> 序列化：Java序列化就是指把Java对象转换为字节序列的过程。</p><p> 反序列化：Java反序列化就是指把字节序列恢复为Java对象的过程。</p></li><li><p>作用：</p><p> 序列化：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。</p><p> 反序列化：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul></li></ol></li></ul><h1 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h1><ul><li><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ol><li><p>ISO-8859-1 收录除ASCII外，还包括修、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。</p></li><li><p>UTF-8 针对Unicode码表的可变长度字符编码</p></li><li><p>GB2312 简体中文</p></li><li><p>GBK 简体中文、扩充</p></li><li><p>BIG5台湾，繁体中文</p></li></ol></li></ul><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><ul><li><h2 id="字符流的父类（抽象类）"><a href="#字符流的父类（抽象类）" class="headerlink" title="字符流的父类（抽象类）"></a>字符流的父类（抽象类）</h2><ol><li><p>Reader: 字符输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Writer: 字符输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] c)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><h2 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h2><ol><li><p>FileReader:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span> <span class="comment">//从流中读取多个字符，将读到内容存入c数组，返回实际读到的字符数;如果达到文件的尾部，则返回-1。</span></span></span><br></pre></td></tr></table></figure></li><li><p>FileWriter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="comment">//一次写多个字符，将b数组中所有字符，写入输出流。</span></span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><ol><li>缓冲流: BufferedReader/ BufferedWriter<ul><li>高效读写</li><li>支持输入换行符。</li><li>可一次写一行、读一行。</li></ul></li></ol></li></ul><ul><li><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ol><li>PrintWriter:<ul><li>封装了print() /println() 方法，支持写入后换行。</li><li>支持数据原样打印</li></ul></li></ol></li><li><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ol><li>桥转换流: InputStreamReader/0utputStreamWriter<ul><li>可将字节流转换为字符流。</li><li>可设置字符的编码方式。</li></ul></li></ol></li></ul><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><ul><li><h2 id="File类-1"><a href="#File类-1" class="headerlink" title="File类"></a>File类</h2><ol><li><p>概念：代表物理盘符中的一个文件或者文件夹。</p></li><li><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">createNewFile() <span class="comment">//创建一个新文件</span></span><br><span class="line">mkdir() <span class="comment">//创建一个新目录</span></span><br><span class="line">delete() <span class="comment">//删除文件或空目录</span></span><br><span class="line">exists() <span class="comment">//判断Pile对象所对象所代表的对象是否存在</span></span><br><span class="line">getAbsolutePath() <span class="comment">// 获取文件的绝对路径</span></span><br><span class="line">getName() <span class="comment">//取得名字</span></span><br><span class="line">getParent() <span class="comment">//获取文件/ 目录所在的目录</span></span><br><span class="line">isDirectory() <span class="comment">//是否是 目录</span></span><br><span class="line">isFile() <span class="comment">//是否是文件</span></span><br><span class="line">length() <span class="comment">//获得文件的长度</span></span><br><span class="line">listFiles() <span class="comment">//列出目录中的所有内容</span></span><br><span class="line">renameTo() <span class="comment">//修改文件名为</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><h2 id="FileFilter接口"><a href="#FileFilter接口" class="headerlink" title="FileFilter接口"></a>FileFilter接口</h2><ol><li><pre><code class="lang-java">public interface FileFilter    boolean accept (File pathname)</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;当调用File类中的1istFiles()方法时，支持传入FileFi1ter接口接口实现.类，对获取文件进行过滤，只有满足条件的文件的才可出现在listFiles()的返回值中。</p></li></ol></li></ul><ul><li><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ol><li><p>Properties: 属性集合</p></li><li><p>特点</p><ul><li><p>存储属性名和属性值</p></li><li><p>属性名和属性值都是字符串类型</p></li><li><p>没有泛型</p></li><li><p>和流有关</p></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超高校级的扯淡——浅谈《弹丸论破》系列</title>
      <link href="/2021/10/11/%E8%B6%85%E9%AB%98%E6%A0%A1%E7%BA%A7%E7%9A%84%E6%89%AF%E6%B7%A1%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88%E3%80%8A%E5%BC%B9%E4%B8%B8%E8%AE%BA%E7%A0%B4%E3%80%8B%E7%B3%BB%E5%88%97/"/>
      <url>/2021/10/11/%E8%B6%85%E9%AB%98%E6%A0%A1%E7%BA%A7%E7%9A%84%E6%89%AF%E6%B7%A1%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88%E3%80%8A%E5%BC%B9%E4%B8%B8%E8%AE%BA%E7%A0%B4%E3%80%8B%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ol><li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;最近闲来无事补完了《弹丸论破2》和《弹丸论破V3》，再加上自己原本就玩过1代并且看过希望篇绝望篇动漫，算是大概结束了这个系列（绝对绝望少女和小说没时间就没补），所以趁着刚通关没多久还有印象大概聊一下这个游戏系列。</p></li></ol><ol><li><h1 id="“不正经”的大逃杀"><a href="#“不正经”的大逃杀" class="headerlink" title="“不正经”的大逃杀"></a>“不正经”的大逃杀</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次知道《弹丸论破》这个系列时，它给我的直观感受就是非常的“不正经” —— 充满着残酷的自相残杀和猎奇作案手法的超现实大逃杀剧本，一个个画风奇特看上去中二的角色，而且每个角色还都有着所谓的“超高校级”的能力设定，再加上一只和可爱怎么都挂不上边的黑白熊，以上这那些离奇的设定曾让我一度怀疑推荐给我这个游戏的人是不是有什么奇怪的癖好。但直到我真的接受了这些设定，抛弃了现实里才有的惯性逻辑思维后才发现，设计出这个游戏的果然不是一般人，因为这游戏太好玩了，完全就停不下来好吗？用游戏2代里的角色狛枝凪斗的话来说，弹丸论破就是一个终极自我合理化的游戏，想玩它就要试着放开现实逻辑的束缚，拥抱它的强行、做作、疯狂和不正常。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;没错，就是这样一个在常人第一眼看来完全不能接受的“不正经”游戏，却偏偏成为了我最爱的文字推理游戏。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;弹丸论破的三代故事大致相同 —— 一群被称为超高校级的高中生醒来后发现被困在了学校中，而且学校还被一只诡异的黑白熊控制着，只有杀掉同学，并在班级审判中成功隐瞒罪行，才能毕业走人，否则就将全员淘汰。玩家平时活动只能在校园内四处乱逛，偶尔和其他角色培养感情（没错一个随时会减员的游戏居然有好感度系统，我就经常一个角色好感度还没攻略满那个角色就领了便当）一旦案件发生，玩家就需要进行调查、搜集证据，参加之后的班级审判，并在班级审判上找出凶手的发言漏洞，淘汰凶手，最后揭露学校的终极秘密。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;除开那些不正经的设定之外，《弹丸论破》其实还算是一个挺正经的传统文字推理游戏，而他与一般同类型游戏）最大的特别之处就是弹丸论破加快了推理节奏，让被动的文字游戏更加动感流畅，让平时静态的文字化身为机枪一般的“言弹”，简单来说就是通过类似弹幕的方式流畅的带出观点，并将玩家手中的证据比作子弹发射，通过反复击破多个矛盾点，一步步接近真相。这或许是为什么弹丸论破自定义为“高速推理动作游戏”以及《弹丸论破》这个译名的由来。面对满屏弹幕的言论和一直倒数的讨论时间，再结合环形审判厅流畅的镜头转换加上声优们声嘶力竭的演出，配上又吵又燃的背景音乐，使得整个辩论过程始终保持着高速运转，真的有一种你来我往唇枪舌战的辩论刺激感。整个学级审判过程绝对可以用惊艳来形容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;弹丸论破的另一个特别之处在于推理的节奏十分流畅，虽然弹丸论破每个案件都格外离奇，但是推理部分却并不显得硬核，和《逆转裁判》一样，推理过程基本只要找齐线索证据，根据审判流程稍加推理，案件流程大多就会水落石出，往往只有最后的指认凶手环节才需要玩家动点脑筋思考指认。同时也正是因为推理难度不高，所以玩家即使身处在混乱吵闹的学级审判上，也能始终保持一贯的逻辑思路，迅速思考反击，再结合证据连续击破矛盾，最终一步步找出事实真相，这样的一系列操作的爽快感完全不亚于在《鬼泣》里打出一套SSS连招。虽然一整套推理流程看似没有什么深层次范围的思考，但大脑在短时间内接收了如此多的信息，并且经历了一次又一次思维的反转，搭配上案件最后漫画式的重演，这种畅快的解密过程，足以让每个玩家为之沉迷。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;不过略显遗憾的是这样的爽快感在《弹丸论破》里已经一代不如一代，一是玩家的审美疲劳，但究其主要原因还是学级审判的形式花样一代比一代多，推理过程中小游戏也层出不穷，二代还算克制，到了V3里，几乎是每一轮讨论就要换一种讨论形式，而整个学级裁判更是变成了小游戏合集，推理过程中隔三差五就冒出一个获取线索需要的小游戏，再加上那最后诡异的音游嘴炮，都对玩家的推理和游玩节奏割裂的十分严重，即使角色们的演出效果没有退步，但优秀的演出也依旧无法挽救那糟糕的游玩体验。其实我并不反感文字游戏里加入其它的创新玩法，但《弹丸论破》本身就是靠着快节奏的高速推理要素来吸引着玩家群体，而那些动则就长达3~5分钟与推理毫无关联的小游戏，完全的破坏了整个游戏核心体验，使它原本的优势完全消耗殆尽。</p></li><li><h1 id="超高校级的青春群像"><a href="#超高校级的青春群像" class="headerlink" title="超高校级的青春群像"></a>超高校级的青春群像</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;《弹丸论破》那鲜明的快节奏文字推理和时髦值漫溢的演出，无疑是文字游戏的优秀代表，但这些只是它的浅层魅力。它能真正让人迈过题材风格的门槛，直面内心那不可名状的羞耻，使玩家全身心投入那充满希望与绝望的中二世界，很大程度上要归功于弹丸论破那堪称一绝的人物塑造。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;《弹丸论破》里虽然很多人物都只是消耗品，但制作组仍然尽力塑造每个人物的独特性（之前提到的好感度就是之一）：首先游戏的世界中的人物各自都有着被称为“超高校级”的特长，这些不同的能力使得玩家能够快速区别16个角色的特点，接着游戏把一部分角色形象设计的比较脸谱化（例如各代主角），这种偏向一般人的刻板形象的设计使得即使刚接触这个游戏系列的玩家也能够很好的接受，而另一部分则设计的比较去脸谱化，这些角色形象更加远离现实人物的逻辑形象，让人一眼难以接受，但却反而加深了对他们的印象，例如同样是水手服少女，舞园沙耶香和腐川冬子的形象就大相径庭，前者拥有出众的颜值属于能一眼被玩家记住的类型，后者虽然形象不佳，但其双面人格的属性带来的巨大反差却使人记忆犹新。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;面对16个不同的角色，制作组尽量在形象、性格、颜值三个属性之一赋予角色独特记忆点，使得玩家在游戏开场的人物对话介绍便能留有每个角色的初步印象。等到玩家大概认识了每个角色后，游戏在人物塑造方面的又一个圈套就展现在玩家的面前了：首先通过每个角色的自我介绍使玩家快速划分群体，热情的角色们，玩家会下意识产生好感；靠谱的会带来依赖；羸弱的使人感到同情；而那些自我为是的、不合群的，玩家也会对他们感到厌恶。所以玩家基本在一开始就会物色好合作目标，也会下意识判断谁有可能未来会成为凶手。同样游戏中的人物也会各自形成不同的团体，有真心真意做好友的，有单向或者双向的CP，也有互相利用的利益团体，这些关系都会在一定程度上干扰玩家的行为判断（常玩AVG游戏的玩家在这时可能连一张大大的人物关系表都在心中画好了）。然后案件爆发，所有烟雾全部散去，真相浮出水面，玩家这时才会发现自己之前看到的甚至判断的结果都出现了巨大偏差。而《弹丸论破》因为表人设的深入人心，玩家看似全程都在根据自己的主观逻辑判断行动从而产生的安全区域内行动，其实殊不知所有的一切都是设计师早已编排好的剧本，接而在最终揭发真凶时产生了心理的巨大反差，更恐怖的是当玩家回过头来细想，才发现所有的线索早就被交代的明明白白，完全没有任何的突兀，就像是看完了一部叙述性诡计的电影。而大多数凶手又都有自己无可奈何的犯罪理由，事后又残忍地遭受”淘汰“，让玩家既对凶手杀人饱受恨意，又对他的遭遇感到同情。这些种种复杂情绪让玩家爱恨交织，回味无穷。</p><p>和凶手一样，受害者往往也有自己背后的故事，这更加使得玩家的认知动摇，为了加强这种迷茫感，游戏甚至多次出现了预判到玩家的预判或者是预判到玩家的预判的预判的预判，你以为他在第二层你在第三层，但其实他总共有五层，这一操作让一些比自以为开始就能看透案件一切的玩家也包括我到了最后也同样会被事实的真相造成的反差打击的心服口服。而也正是这种在事实与假象之间来回徘徊的迷茫感，使得我游戏里走得每一步都小心翼翼。不得不承认《弹丸论破对》玩家心理揣摩的准确。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后游戏还有一个针对系列核心粉丝的圈套，专门用于应对玩过系列前作比较有经验的玩家，新作故意设计前作中相似的人物、作案手法，引导强烈的暗示，在收割情怀的同时把经验丰富的老玩家也骗的团团转。另外优秀的人物塑造也让玩家下意识的实现自我欺骗，让玩家始终不愿意相信自己看上的角色会是凶手/被害人，当自己关注的角色被杀，或者在指认犯人环节指认了一圈都是错误最后极不情愿的指出自己钟爱的角色时，那种难以名状的感觉估计只有亲身游玩过的人才懂。</p></li><li><h1 id="充满绝望与希望的文字AVG"><a href="#充满绝望与希望的文字AVG" class="headerlink" title="充满绝望与希望的文字AVG"></a>充满绝望与希望的文字AVG</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;综上所述，弹丸论破是一个很懂得唤醒厨力的作品。鲜明的角色塑造，跌宕的案件设计，不算硬核但还算严谨的推理，能够满足大部分不同类型玩家的需求，其中也不缺乏像第二代第五个案件这种将前面所有特征全部融为一体，只存在于《弹丸论破》世界观的神级案例。如今的游戏在画面和玩法上都有了更多的可能，像《弹丸论破》、《逆转裁判》这一类的文字冒险游戏似乎变得不再大众，即使诞生了《十三机兵防卫队》这样的新时代神作，也改变不了这一类游戏边缘化的事实。但我永远都不会忘记曾经有这样一个游戏，仅仅靠着一张张风格迥异的图片就能给我带来如此复杂的情感。希望弹丸论破不会像V3里说的那样真的完结，期待希望与绝望的下一次对决。</p><p><img src="https://i.loli.net/2021/10/12/8fovalzPNX4SrRn.jpg" alt="弹丸论破02.jpg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 第九艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第九艺术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
